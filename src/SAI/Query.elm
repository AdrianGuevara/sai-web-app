-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module SAI.Query exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import SAI.Enum.CivilState
import SAI.Enum.EventStatus
import SAI.Enum.EventType
import SAI.Enum.Gender
import SAI.Enum.LevelAccess
import SAI.Enum.Status
import SAI.InputObject
import SAI.Interface
import SAI.Object
import SAI.Scalar
import SAI.ScalarCodecs
import SAI.Union


type alias PeopleOptionalArguments =
    { after : OptionalArgument String
    , first : OptionalArgument Int
    , status : OptionalArgument SAI.Enum.Status.Status
    , gender : OptionalArgument SAI.Enum.Gender.Gender
    , civilStatus : OptionalArgument SAI.Enum.CivilState.CivilState
    , query : OptionalArgument String
    }


{-|

  - after -
  - first -
  - status -
  - gender -
  - civilStatus -
  - query -

-}
people : (PeopleOptionalArguments -> PeopleOptionalArguments) -> SelectionSet decodesTo SAI.Object.PersonConnection -> SelectionSet decodesTo RootQuery
people fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { after = Absent, first = Absent, status = Absent, gender = Absent, civilStatus = Absent, query = Absent }

        optionalArgs =
            [ Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "status" filledInOptionals.status (Encode.enum SAI.Enum.Status.toString), Argument.optional "gender" filledInOptionals.gender (Encode.enum SAI.Enum.Gender.toString), Argument.optional "civilStatus" filledInOptionals.civilStatus (Encode.enum SAI.Enum.CivilState.toString), Argument.optional "query" filledInOptionals.query Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "people" optionalArgs object_ identity


type alias PersonRequiredArguments =
    { id : SAI.ScalarCodecs.Id }


{-|

  - id -

-}
person : PersonRequiredArguments -> SelectionSet decodesTo SAI.Object.Person -> SelectionSet (Maybe decodesTo) RootQuery
person requiredArgs object_ =
    Object.selectionForCompositeField "person" [ Argument.required "id" requiredArgs.id (SAI.ScalarCodecs.codecs |> SAI.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias GroupsOptionalArguments =
    { status : OptionalArgument SAI.Enum.Status.Status
    , query : OptionalArgument String
    , userId : OptionalArgument SAI.ScalarCodecs.Id
    }


{-|

  - status -
  - query -
  - userId -

-}
groups : (GroupsOptionalArguments -> GroupsOptionalArguments) -> SelectionSet decodesTo SAI.Object.Group -> SelectionSet (List decodesTo) RootQuery
groups fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { status = Absent, query = Absent, userId = Absent }

        optionalArgs =
            [ Argument.optional "status" filledInOptionals.status (Encode.enum SAI.Enum.Status.toString), Argument.optional "query" filledInOptionals.query Encode.string, Argument.optional "userId" filledInOptionals.userId (SAI.ScalarCodecs.codecs |> SAI.Scalar.unwrapEncoder .codecId) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "groups" optionalArgs object_ (identity >> Decode.list)


type alias GroupRequiredArguments =
    { id : SAI.ScalarCodecs.Id }


{-|

  - id -

-}
group : GroupRequiredArguments -> SelectionSet decodesTo SAI.Object.Group -> SelectionSet (Maybe decodesTo) RootQuery
group requiredArgs object_ =
    Object.selectionForCompositeField "group" [ Argument.required "id" requiredArgs.id (SAI.ScalarCodecs.codecs |> SAI.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias UsersOptionalArguments =
    { status : OptionalArgument SAI.Enum.Status.Status
    , levelAccess : OptionalArgument SAI.Enum.LevelAccess.LevelAccess
    , group : OptionalArgument String
    }


{-|

  - status -
  - levelAccess -
  - group -

-}
users : (UsersOptionalArguments -> UsersOptionalArguments) -> SelectionSet decodesTo SAI.Object.Person -> SelectionSet (List decodesTo) RootQuery
users fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { status = Absent, levelAccess = Absent, group = Absent }

        optionalArgs =
            [ Argument.optional "status" filledInOptionals.status (Encode.enum SAI.Enum.Status.toString), Argument.optional "levelAccess" filledInOptionals.levelAccess (Encode.enum SAI.Enum.LevelAccess.toString), Argument.optional "group" filledInOptionals.group Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "users" optionalArgs object_ (identity >> Decode.list)


type alias EventsOptionalArguments =
    { group : OptionalArgument SAI.ScalarCodecs.Id
    , status : OptionalArgument SAI.Enum.Status.Status
    , fatherEvent : OptionalArgument SAI.ScalarCodecs.Id
    , eventStatus : OptionalArgument SAI.Enum.EventStatus.EventStatus
    , query : OptionalArgument String
    , type_ : OptionalArgument SAI.Enum.EventType.EventType
    }


{-|

  - group -
  - status -
  - fatherEvent -
  - eventStatus -
  - query -
  - type\_ -

-}
events : (EventsOptionalArguments -> EventsOptionalArguments) -> SelectionSet decodesTo SAI.Object.Event -> SelectionSet (List decodesTo) RootQuery
events fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { group = Absent, status = Absent, fatherEvent = Absent, eventStatus = Absent, query = Absent, type_ = Absent }

        optionalArgs =
            [ Argument.optional "group" filledInOptionals.group (SAI.ScalarCodecs.codecs |> SAI.Scalar.unwrapEncoder .codecId), Argument.optional "status" filledInOptionals.status (Encode.enum SAI.Enum.Status.toString), Argument.optional "fatherEvent" filledInOptionals.fatherEvent (SAI.ScalarCodecs.codecs |> SAI.Scalar.unwrapEncoder .codecId), Argument.optional "eventStatus" filledInOptionals.eventStatus (Encode.enum SAI.Enum.EventStatus.toString), Argument.optional "query" filledInOptionals.query Encode.string, Argument.optional "type" filledInOptionals.type_ (Encode.enum SAI.Enum.EventType.toString) ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "events" optionalArgs object_ (identity >> Decode.list)


type alias EventRequiredArguments =
    { id : SAI.ScalarCodecs.Id }


{-|

  - id -

-}
event : EventRequiredArguments -> SelectionSet decodesTo SAI.Object.Event -> SelectionSet (Maybe decodesTo) RootQuery
event requiredArgs object_ =
    Object.selectionForCompositeField "event" [ Argument.required "id" requiredArgs.id (SAI.ScalarCodecs.codecs |> SAI.Scalar.unwrapEncoder .codecId) ] object_ (identity >> Decode.nullable)


type alias LoginRequiredArguments =
    { username : String
    , password : String
    }


{-|

  - username -
  - password -

-}
login : LoginRequiredArguments -> SelectionSet decodesTo SAI.Object.LoginResult -> SelectionSet decodesTo RootQuery
login requiredArgs object_ =
    Object.selectionForCompositeField "login" [ Argument.required "username" requiredArgs.username Encode.string, Argument.required "password" requiredArgs.password Encode.string ] object_ identity
